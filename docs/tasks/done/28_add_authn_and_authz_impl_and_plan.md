### Task: Dual-Mode AuthN/AuthZ Using `init.ps1` + `secrets.local.json.template` (No local IdP required)
**Priority:** High  
**Complexity:** Low  
**Description:**  
Enable JWT authentication & policy-based authorization for both APIs (**Insurance** and **Vehicle**) without requiring a local identity provider. Use a **dual-mode** config driven by `init.ps1` + `.env` + User Secrets:
- **Local Mode (default):** If `JwtAuthority` is empty, validate tokens with a generated **DevSymmetricKey** and configured **Issuer** + **Audience**.
- **IdP Mode (optional):** If `JwtAuthority` is set, automatically switch to validating against that **Authority** (OIDC discovery), no code changes.

**Affected Files:**
- `init.ps1` (reads template, creates `.env`, sets User Secrets)
- `secrets.local.json.template` (extend with JWT keys)
- `src/Insurance/Insurance.Service/Program.cs` (dual-mode JWT)
- `src/Vehicle/Vehicle.Service/Program.cs` (dual-mode JWT)
- `.env` (generated by `init.ps1`)

---

## Action Points

1. **Update `secrets.local.json.template` (add optional JWT keys)**
   ```json
   {
     "DB_SA_PASSWORD": "Passw0rd!123",

     // ===== Optional JWT settings =====
     // Leave JwtAuthority empty for local symmetric-key mode.
     // Set to issuer URL (e.g., https://idp.example.com/realms/dev) to enable IdP mode.
     "JwtAuthority": "",
     // Use one shared audience or create service-specific audiences if you prefer.
     "JwtAudience": "api://insurance-service",
     // Used only in local mode (no IdP)
     "JwtIssuer": "https://local-dev-issuer"
   }
   ```
   > If you want **separate audiences**, add `"VehicleJwtAudience": "api://vehicle-service"` and adjust step 2 accordingly.

2. **Modify `init.ps1` to populate `.env` and User Secrets (dual-mode)**
   Add a small block **after** you load `secrets.local.json` and **before** you finish writing `.env`/User Secrets:
   ```powershell
   # ---- JWT Dual-Mode ----
   $jwtAuthority = $secretsConfig.JwtAuthority
   $jwtAudience  = if ($secretsConfig.JwtAudience) { $secretsConfig.JwtAudience } else { "api://insurance-service" }
   $jwtIssuer    = if ($secretsConfig.JwtIssuer)   { $secretsConfig.JwtIssuer }   else { "https://local-dev-issuer" }
   $useIdp = -not [string]::IsNullOrWhiteSpace($jwtAuthority)

   function New-DevSymmetricKey {
     [byte[]]$b = New-Object byte[] 32
     [System.Security.Cryptography.RandomNumberGenerator]::Fill($b)
     return [Convert]::ToBase64String($b)
   }

   # Append to .env based on mode
   if ($useIdp) {
     Add-Content -Path $envFile -Value "Jwt__Authority=$jwtAuthority"
     Add-Content -Path $envFile -Value "Jwt__Audience=$jwtAudience"
   } else {
     $devKey = New-DevSymmetricKey
     Add-Content -Path $envFile -Value "Jwt__Authority="
     Add-Content -Path $envFile -Value "Jwt__Issuer=$jwtIssuer"
     Add-Content -Path $envFile -Value "Jwt__Audience=$jwtAudience"
     Add-Content -Path $envFile -Value "Jwt__DevSymmetricKey=$devKey"
   }

   # Set User Secrets for both services
   $apiProjects = @(
     "src/Insurance/Insurance.Service/Insurance.Service.csproj",
     "src/Vehicle/Vehicle.Service/Vehicle.Service.csproj"
   )
   foreach ($proj in $apiProjects) {
     dotnet user-secrets init --project $proj | Out-Null
     if ($useIdp) {
       dotnet user-secrets set "Jwt:Authority" "$jwtAuthority" --project $proj
       dotnet user-secrets set "Jwt:Audience"  "$jwtAudience"  --project $proj
       dotnet user-secrets remove "Jwt:Issuer"          --project $proj | Out-Null
       dotnet user-secrets remove "Jwt:DevSymmetricKey" --project $proj | Out-Null
     } else {
       dotnet user-secrets set "Jwt:Authority" ""            --project $proj
       dotnet user-secrets set "Jwt:Issuer"    "$jwtIssuer"  --project $proj
       dotnet user-secrets set "Jwt:Audience"  "$jwtAudience"--project $proj
       dotnet user-secrets set "Jwt:DevSymmetricKey" "$devKey" --project $proj
     }
   }
   ```
   > If using **separate Vehicle audience**, compute `$vehicleAudience = $secretsConfig.VehicleJwtAudience` and set `Jwt__Audience`/`Jwt:Audience` differently for the Vehicle project.

3. **Implement dual-mode JWT in both APIs**
   Apply the same snippet to **both** `Program.cs` files:
   ```csharp
   using System.Text;
   using Microsoft.AspNetCore.Authentication.JwtBearer;
   using Microsoft.IdentityModel.Tokens;

   var builder = WebApplication.CreateBuilder(args);

   var jwt = builder.Configuration.GetSection("Jwt");
   var authority = jwt["Authority"];
   var audience  = jwt["Audience"];
   var issuer    = jwt["Issuer"];
   var devKey    = jwt["DevSymmetricKey"];

   builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
       .AddJwtBearer(options =>
       {
           if (!string.IsNullOrWhiteSpace(authority))
           {
               // IdP mode
               options.Authority = authority;
               options.Audience  = audience;
               options.RequireHttpsMetadata = !builder.Environment.IsDevelopment();
           }
           else
           {
               // Local symmetric-key mode
               if (string.IsNullOrWhiteSpace(devKey))
                   throw new InvalidOperationException("Jwt:DevSymmetricKey must be set when Jwt:Authority is empty.");

               options.TokenValidationParameters = new TokenValidationParameters
               {
                   ValidateIssuer = !string.IsNullOrWhiteSpace(issuer),
                   ValidIssuer = issuer,
                   ValidateAudience = !string.IsNullOrWhiteSpace(audience),
                   ValidAudience = audience,
                   ValidateIssuerSigningKey = true,
                   IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(devKey)),
                   ValidateLifetime = true,
                   ClockSkew = TimeSpan.FromSeconds(30)
               };
           }
       });

   builder.Services.AddAuthorization(options =>
   {
       options.AddPolicy("insurance:read",  p => p.RequireClaim("scope", "insurance:read"));
       options.AddPolicy("insurance:write", p => p.RequireClaim("scope", "insurance:write"));
       options.AddPolicy("vehicle:read",    p => p.RequireClaim("scope", "vehicle:read"));
       options.AddPolicy("vehicle:write",   p => p.RequireClaim("scope", "vehicle:write"));
       options.AddPolicy("AdminOnly",       p => p.RequireRole("admin"));
   });

   builder.Services.AddControllers();
   var app = builder.Build();
   app.UseHttpsRedirection();
   app.UseAuthentication();
   app.UseAuthorization();
   app.MapControllers();
   app.Run();
   ```

4. **(Optional) Controller attributes**
   - Insurance endpoints: `[Authorize(Policy = "insurance:read")]`, `[Authorize(Policy = "insurance:write")]`
   - Vehicle endpoints: `[Authorize(Policy = "vehicle:read")]`, `[Authorize(Policy = "vehicle:write")]`
   - Shared admin gate: `[Authorize(Policy = "AdminOnly")]`

---

## Verification

1. **Local Mode (default)**
   - Keep `JwtAuthority` **empty** in `secrets.local.json` (created from the updated template).
   - Run `init.ps1`.
   - Confirm `.env` contains:
     - `Jwt__Authority=` (empty), `Jwt__Issuer`, `Jwt__Audience`, `Jwt__DevSymmetricKey`.
   - Start both APIs (IDE or Docker).  
   - Call secured endpoints with a JWT signed using `Jwt__DevSymmetricKey`, and matching `iss`/`aud`.  
     - Insurance `GET` with `insurance:read` → **200**  
     - Vehicle `GET` with `vehicle:read` → **200**  
     - Missing scope → **403**

2. **IdP Mode**
   - Set `JwtAuthority` (e.g., `https://idp.example.com/realms/dev`) in `secrets.local.json`.
   - Run `init.ps1`.
   - `.env` now has `Jwt__Authority` & `Jwt__Audience` (no local key/issuer).
   - Start APIs; issue tokens from IdP → validation succeeds via OIDC discovery.

3. **Per-service audience (optional)**
   - Add `"VehicleJwtAudience": "api://vehicle-service"` in the template.
   - Update `init.ps1` to set Vehicle’s `Jwt__Audience`/`Jwt:Audience` accordingly.
   - Verify Vehicle API only accepts tokens with its audience.

---

## Notes
- **No local IdP required**; switching to IdP is **config-only**.
- **`init.ps1` remains the single entry point**: it creates `.env` and sets User Secrets for both APIs.
- Keep dev key out of source control (User Secrets + `.env` are fine for local).  
- Prefer **scopes** for API permissions; use **roles** for coarse admin gating.
